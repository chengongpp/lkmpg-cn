# 热身

## 5.1 模块的开始和结束

程序一般以`main()`函数打头，执行一系列指令，执行完之后终止。内核模块的运作方式有些不同。内核模块总是以`init_module`或是你在`module_init`中指定的函数打头，这就是模块的入口函数；它告知内核该模块提供的功能，并设置好内核，以在需要的时候把模块内的函数跑起来。执行到这一步时，入口函数返回后，模块本身不会有什么操作，而是到内核需要调到模块提供的指令时才调用。

所有模块都以调用`cleanup_module`或你在`module_exit`指定的函数结束，这就是模块的退出函数。它将入口函数做过的所有操作还原，把入口函数注册过的函数卸载。

每个模块都必须有一个入口函数和一个退出函数。因为指定入口和退出函数的方式不止一种，我将尽量使用“入口函数”和“退出函数”这两个术语，但有时我说惯了直接用`init_module`和`cleanup_module`，你应该也能理解我指的是什么。

## 5.2 可用于模块的函数

程序员一直以来都在使用并不由他们定义的函数。最简单的例子就是`printf()`，你经常用这类由C标准库libc提供的库函数。这些函数的定义直到链接阶段才真正进入你的程序中，这个阶段也确保了对应指令（例如printf()的指令）可用，并将调用指令指向该指令。

内核模块在这方面也有所不同。在hello world例子当中，你可能已经注意到了，我们使用了`pr_info()`函数，但并没有将标准IO库包含进来。这是因为内核模块目标文件的符号在`insmod`或`modprobe`执行时才被解析。对这些符号的定义包含在内核当中，你使用的外部函数全部都只能由内核提供。如果你想知道内核导出了哪些函数符号，可以看看`/proc/kallsyms`。

你需要将库函数和系统调用的不同点牢记在心。库函数更加高阶，完全在用户空间运行，并给程序员提供了更加方便的接口去调用真正干活的函数——系统调用。系统调用由内核提供，代表用户在内核模式运行。库函数`printf()`看起来可能像个很通用的输出函数，但它实际上会把数据格式化成对应字符串，然后使用类似`write()`的底层系统调用写出字符串的数据，从而将数据送到标准输出。

你想知道`printf()`进行了哪些系统调用吗？好说！使用`gcc -Wall -o hello hello.c`编译如下程序：

```c
#include <stdio.h> 
 
int main(void) 
{ 
    printf("hello"); 
    return 0; 
}
```

然后使用`strace ./hello`运行它。有没有让你爽到？你看到的每一行都对应一个系统调用。[stace](https://strace.io/)是一个很趁手的程序，可以给你提供程序执行了哪些系统调用等细节，包括调用名、调用的参数和调用的返回值。在找出程序尝试访问的文件等场景上，它是个无价的工具。直接看到最后，你会看到一行内容，类似于`write(1, "hello", 5hello)`。就在这儿，我们解开了`printf()`面纱背后的内容。你可能不熟`write`，毕竟大多数人都用库函数做文件IO（像`fopen`、`fputs`和`fclose`）。如果确实如此，你可以看看`man 2 write`。man手册的第二节用于记录系统调用（如`kill()`和`read()`）文档。第3节用于记录库函数调用，你可能更熟悉这部分（如`cosh()`和`random()`）。

你甚至可以通过模块替换内核中的系统调用，我们后面会简单实践一下。黑客经常用这类手段来制造后门和木马，但你也可以写你自己的模块来多行善事，比如说在有人想删你系统上的文件时，让内核输出“啼嘿，笑啦”。

## 5.3 用户空间和内核空间

内核，一言以蔽之就是资源访问管理。在具体场景中，资源可以是显卡、硬盘甚至是内存。程序经常为了同一个资源发生竞争。比如说，我刚保存个文件，updatedb开始更新区域数据库，我的vim会话和updatedb就在并发使用硬盘。内核需要保持他们有序运行，并在用户想访问资源时拒绝访问。为了实现上述功能，CPU可以运行在不同的模式。每个模式都给你不同程度的自由度，让你在系统上执行你想要的操作。Intel 80386架构有4个模式，我们称之为环（ring）。Unix只使用两个环：最高权限的环（ring 0，也就是“超管模式”，任何操作都可以进行）和最低权限的环，也就是“用户模式”。

回顾上面对库函数和系统调用的讨论。一般来说，你在用户空间调用库函数。库函数会调用一个及以上的系统调用，这些系统调用以库函数的名义在超管模式执行操作，因为他们是内核的一部分。系统调用完成任务后返回，程序回到用户空间继续执行。

## 5.4 命名空间

在你写小型C程序的时候，你会用读者看得懂的、方便行事的变量名。然而有时候，你写的流程可能只是更大的程序中的一部分，你用到的全局变量可能只是社群里别的开发者的局部变量；有些变量名就可能会冲突。在程序使用了大量语焉不详的全局变量时，你就会遇到命名空间污染。在大型项目中，必须采取措施来记录好保留的变量名，并设法树立规范来为变量和符号取独特的名字。

在写内核代码时，即使最小的模块也会被被链接到整个内核中，所以命名问题绝对值得重视。最好的处理方式是将你所有的变量声明为`static`，并使用规范的前缀命名你的符号。按惯例，所有的内核代码前缀都是小写的。如果你不想把所有东西都声明为`static`，另一个选择是声明一个符号表，然后将符号表注册在内核中。我们稍后会讨论这个问题。

`/proc/kallsyms`文件记录了内核所知道的所有符号，可以在你的模块中访问到，因为它们都共用内核的内存空间。

## 5.5 内存空间

内存管理是一门博大精深的学问，O'Reilly出版的[《深入理解Linux内核》](https://www.oreilly.com/library/view/understanding-the-linux/0596005652/)一书就专门讲解了内存管理！我们不需要成为内存管理专家，但我们在开始真正的内核模块编写前，有必要了解一些知识。

如果你对段错误没有概念，你可能会对“指针并不真实指向对应的内存区域”这一事实感到惊讶。在一个进程被创建时，内核在物理内存中划出一个区域，交给该进程去执行它对应的代码段、变量、堆栈和其他数据，计算机科学家在这方面比较在行。这片内存从0x00000000开始，扩展到它所需要的大小。任意两个进程的内存空间都不会重叠，每个进程访问到的地址，比如说0xbffff978，实际上将会访问到物理内存上的不同位置！具体的过程是：一个特定进程访问名为0xbffff978的索引，该索引指向到某个偏移量，该偏移量指定了内存中为这个进程划出来的一片区域。多数情况下，像我们写的Hello World之类的进程，并不能访问到别的进程的内存空间。尽管也有一些手段可以做到，我们后面会提到。

内核也有它自己的内存空间。模块是能够在内核中动态加载/移除的一堆代码段（相对于半自动的目标文件而言），所以它共用内核的内存空间，并不享有独立的部分。所以，你的模块发生了段错误也就意味着内核发生了段错误。如果你因为缺一错误而在写数据时越了界，你就会破坏内核的数据（或代码段）。实际情况比表面上听起来还要糟糕，所以你必须尽力保持小心谨慎地编写你的模块。

顺便，我想说明一下，以上的讨论都是针对宏内核系统而言的。尽管思想类似，宏内核的含义和“将你所有的模块都编译到内核中”并不一样。有些被称之为微内核的设计，他们的模块享有自己独立的内存空间。比如[GNU Hurd](https://www.gnu.org/software/hurd/)和谷歌Fuchsia的[Zircon内核](https://fuchsia.dev/fuchsia-src/concepts/kernel)就是微内核的例子。

## 5.6 设备驱动

设备驱动是内核模块中的一类，主要是为硬件设备提供功能支持，比如串口。在Unix上，每个硬件都被表示成`/dev`下的文件，称为设备文件，提供与硬件进行通信的手段。设备驱动代表用户程序提供同硬件的通信。比如`es1370.ko`声卡驱动可能会将`/dev/sound`设备文件对接到Ensoniq IS1370声卡上。用户空间的程序，比如像mp3blaster，可以直接使用`/dev/sound`，而不需要知道背后安装声卡的具体型号。

一起来看一些设备文件。以下是表示第一块主IDE硬盘前三个分区的设备文件：

```plaintext
$ ls -l /dev/hda[1-3]
brw-rw----  1 root  disk  3, 1 Jul  5  2000 /dev/hda1
brw-rw----  1 root  disk  3, 2 Jul  5  2000 /dev/hda2
brw-rw----  1 root  disk  3, 3 Jul  5  2000 /dev/hda3
```

注意被逗号分隔开两个数字的那列。第一个数字被称为设备的主设备号（major number），第二个被称为次设备号（minor number）。主设备号指示了访问硬件的是哪个驱动。每个驱动都被单独分配有一个主设备号。所有标有相同的主设备号的设备文件都是由同一个驱动提供的。上面所有的主设备号都是3，因为他们都由同一个驱动控制。

次设备号被驱动用于区分它所控制的不同硬件。再看看上面的例子，尽管三个设备都由同一个驱动控制，但它们有不同的次设备号，因为驱动将它们视作硬件中的不同部分。

设备分为两类：字符设备和块设备。区别在于，块设备对访问请求划有缓存，可以选择最佳的安排去回应从主机接收到的请求。对于存储设备来说这种机制很重要，比如读写邻近区域的扇区就比操作离得比较远的扇区要快。还有一个不同点，块设备只能以块的方式进行输入输出（块的大小可以因设备而异），而字符设备容许按需读取任意多的字节。世界上多数设备是字符设备，因为他们不需要缓存机制，且不按照固定尺寸的块去交互操作。你可以通过`ls -l`命令的第一个字符去判断设备文件是块设备还是字符设备，如果字符是`b`就说明是块设备，而如果是`c`就说明是字符设备。上面给的例子中的都是块设备。以下是字符设备的例子（串口设备）。

```plaintext
crw-rw----  1 root  dial 4, 64 Feb 18 23:34 /dev/ttyS0
crw-r-----  1 root  dial 4, 65 Nov 17 10:26 /dev/ttyS1
crw-rw----  1 root  dial 4, 66 Jul  5  2000 /dev/ttyS2
crw-rw----  1 root  dial 4, 67 Jul  5  2000 /dev/ttyS3
```

如果你想知道主设备号的分配情况，可以参考[Documentation/admin-guide/devices.txt](https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/tree/Documentation/admin-guide/devices.txt)。

设备安装好后，所有的设备文件都经由`mknod`命令创建。要想创建一个名为`coffee`的，主次设备号为12和2的新的字符设备，执行`mknod /dev/coffee c 12 2`即可。并不是一定要把设备文件放到`/dev`，但按惯例就是这么做。Linus把他的设备塞到了`/dev`，所以你最好也这么整。不过，在出于测试目的创建设备文件时，把文件放在你编译内核模块的工作目录下大概也没问题。但一定要确保在你的驱动写好之后把它放到正确的地方。

上面的探讨中还有几个没有明讲的点，我现在趁机说明一下。在访问设备文件时，内核会根据文件的主设备号决定采用哪一个驱动去处理访问。也就是说内核并不真的需要用到甚至知道次设备号。只有驱动本身需要关心次设备号。驱动使用次设备号区分硬件上不同的部分。

顺便一提，我说*硬件*的时候，我指的是比你手头的PCI卡更抽象一点的玩意。看以下两个设备文件：

```plaintext
$ ls -l /dev/sda /dev/sdb
brw-rw---- 1 root disk 8,  0 Jan  3 09:02 /dev/sda
brw-rw---- 1 root disk 8, 16 Jan  3 09:02 /dev/sdb
```

现在你看到这两个设备文件就能立刻知道他们是由同一个驱动处理的块设备（主设备号为8，有块设备标记）。有时两个主设备号相同次设备号不同的设备也可以表示物理硬件上相同的部位。所以注意我们讨论中提到的“硬件”可能是个非常抽象而并非物理存在的概念。
